[{"content":" User Logs In: The user accesses the SSO portal (or initiates login through a service provider) and enters their credentials (username and password). Credential Verification: The SSO system sends the credentials to an authentication server, which could use protocols like LDAP, Active Directory (AD), OAuth, or SAML to verify the user’s identity. Authentication: The authentication server checks the credentials against a database (like AD or a cloud identity service) and either approves or denies the login request. Token Issuance: If the credentials are correct, the SSO system issues an authentication token, which can be in the form of a JWT, SAML assertion, or OAuth token. Accessing Applications: The user uses this token to request access to various linked applications without re-entering their credentials. Application Verification: Each application the user tries to access checks the validity of the token with the SSO system or validates it locally based on the application\u0026rsquo;s configuration. Session Management: The user remains authenticated across multiple applications until the session expires or the user logs out. Different Protocols Used in SSO: SAML (Security Assertion Markup Language): XML-based, widely used in enterprise environments for browser-based SSO. OAuth (Open Authorization): Token-based, typically used in mobile and web apps for secure API access. OpenID Connect (OIDC): Built on top of OAuth 2.0, it adds an identity layer to OAuth, making it suitable for both authentication and authorization. SAML (Security Assertion Markup Language) SAML is an XML-based protocol that enables Single Sign-On (SSO) by exchanging authentication and authorization data between two entities: the Identity Provider (IdP) and the Service Provider (SP). It is commonly used in enterprise environments to allow users to access multiple web applications without having to log in repeatedly.\nKey Components Identity Provider (IdP): The system that authenticates the user and stores their digital identity. Examples of IdPs include Active Directory Federation Services (ADFS) or Okta. Service Provider (SP): The application or service that the user is trying to access (e.g., Salesforce, Google Apps). The SP relies on the IdP to authenticate the user. SAML Assertion A SAML assertion is an XML document generated by the IdP, which contains the user’s identity information and authentication status. It serves as proof that the user has been authenticated.\nThe SAML assertion includes:\nAttributes: Information about the user (e.g., name, email, roles, permissions). Issuer: The IdP that generated the assertion. Signature: A digital signature from the IdP to ensure the assertion cannot be altered in transit. Conditions: Time constraints like validity period (issue time and expiration). Subject Confirmation: A mechanism ensuring that the assertion is presented by the right user. SAML Workflow SAML operates in two major flows: SP-initiated and IdP-initiated. ![[Pasted image 20241017123054.png]]\n1. SP-Initiated Flow: Step 1: The user attempts to access an application (SP) but is not authenticated yet. Step 2: The SP generates a SAML authentication request and redirects the user to the IdP. Step 3: The user logs in to the IdP (if not already authenticated). Step 4: Upon successful authentication, the IdP generates a SAML assertion and redirects the user back to the SP. Step 5: The SP validates the SAML assertion (verifying the digital signature and expiration). Step 6: If valid, the SP grants access to the user. 2. IdP-Initiated Flow: Step 1: The user accesses the IdP directly and logs in. Step 2: After successful authentication, the IdP generates a SAML assertion. Step 3: The IdP sends the SAML assertion to the SP, often via a browser redirect. Step 4: The SP validates the assertion and grants access to the user. SAML Protocols SAML consists of three main protocols:\nAuthentication Request Protocol: The SP sends a request to the IdP asking for an authentication assertion.\nAssertion Protocol: The IdP responds to the authentication request with an assertion, confirming whether the user is authenticated.\nArtifact Resolution Protocol: A method where the IdP can send an artifact (a reference to the assertion) instead of sending the full assertion directly, improving security.\nSAML Bindings SAML supports multiple binding mechanisms, the most common of which are:\nHTTP Redirect Binding: Used to pass the SAML authentication request from the SP to the IdP via an HTTP redirect. HTTP POST Binding: The SAML assertion is passed back from the IdP to the SP via an HTTP POST request. SOAP Binding: Used for back-channel communication between the IdP and SP. This ensures that messages are exchanged securely between them without relying on the user\u0026rsquo;s browser. In-depth Security in SAML SAML includes robust security mechanisms to ensure the confidentiality, integrity, and authenticity of the authentication and authorization processes.\n1. Digital Signatures Purpose: Digital signatures are used to ensure the integrity and authenticity of SAML assertions and requests.\nHow It Works:\nThe IdP digitally signs the SAML assertion using its private key. The SP validates the signature using the IdP’s public key. This process ensures that the assertion has not been tampered with during transmission and that it originated from the trusted IdP. Without digital signatures, attackers could alter assertions to elevate permissions, impersonate users, or extend the session\u0026rsquo;s validity.\n2. Encryption Purpose: Encryption ensures the confidentiality of sensitive information, such as user attributes, within a SAML assertion.\nHow It Works:\nThe IdP can encrypt parts of the SAML assertion using the SP\u0026rsquo;s public key. Only the SP can decrypt the encrypted parts using its private key. This ensures that sensitive data, like user roles and permissions, remains confidential and secure in transit. While encryption of the assertion itself is optional, it is often implemented when sensitive user attributes are exchanged.\n3. Replay Attack Prevention Purpose: Prevent an attacker from resubmitting a SAML assertion that has already been used to gain unauthorized access.\nHow It Works:\nSAML assertions include timestamps that specify their validity window (usually a few minutes). Nonces are used to identify requests uniquely, ensuring each assertion can be used only once. The SP checks the validity of the timestamp and ensures the assertion has not been replayed within the allowed time frame. By doing so, SAML prevents attackers from capturing a valid SAML assertion and reusing it later to gain unauthorized access.\n4. Mutual Authentication Between IdP and SP Purpose: Ensure both parties (IdP and SP) are communicating securely and trust each other. How It Works: Certificates are exchanged between the IdP and SP during the initial setup. Both parties store each other’s public keys. During communication, the IdP signs assertions, and the SP verifies them using the stored public key. This mutual authentication ensures that neither party is impersonating the other, preventing man-in-the-middle attacks. 5. Single Logout (SLO) Purpose: Allow users to log out from all connected applications (SPs) with one action. How It Works: When a user logs out from one application, the SP sends a Logout Request to the IdP. The IdP then notifies all other SPs involved in the user’s session, instructing them to log the user out as well. This centralized logout process ensures that once the user logs out from one service, they are logged out from all services connected via SSO. 6. Transport Layer Security (TLS) Purpose: SAML messages are usually transmitted over HTTPS, ensuring the data exchanged between the IdP and SP is protected by TLS. How It Works: TLS provides encryption, data integrity, and server authentication, securing the communication channel. While the SAML messages themselves are signed and may be encrypted, using TLS adds an additional layer of security, protecting against network-level attacks (e.g., packet sniffing). ","permalink":"//localhost:1313/posts/apm/sso/","summary":"This is sparta","title":"What is SSO"},{"content":"Save Output to a File Command:\n1 curl -o output.html http://example.com What it does:\nSaves the content of the webpage to a file named output.html.\nFollow Redirects 1 curl -L http://example.com What it does:\nFollows any HTTP redirects and fetches the final destination page.\nShow HTTP Headers Command:\n1 curl -I http://example.com What it does:\nDisplays only the HTTP headers (e.g., status code, content type) of the requested page.\nDownload a File Command:\n1 curl -O http://example.com/file.zip What it does:\nDownloads a file from the URL and saves it with the same name as on the server.\nSend a GET Request with Parameters Command:\n1 curl \u0026#34;http://example.com/api?param1=value1\u0026amp;param2=value2\u0026#34; What it does:\nSends a GET request with query parameters to the server.\nSend Data with a POST Request Command:\n1 curl -X POST -d \u0026#34;key1=value1\u0026amp;key2=value2\u0026#34; http://example.com/api What it does:\nSends data using the POST method to an API or server.\nInclude Custom Headers Command:\n1 curl -H \u0026#34;Authorization: Bearer YOUR_TOKEN\u0026#34; http://example.com/api What it does:\nSends a request with a custom HTTP header, such as an API authorization token.\nSend JSON Data Command:\n1 curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;key\u0026#34;:\u0026#34;value\u0026#34;}\u0026#39; http://example.com/api What it does:\nSends JSON-formatted data to an API endpoint using a POST request.\nTest a Server’s Response Time Command:\n1 curl -w \u0026#34;Time: %{time_total}s\\n\u0026#34; -o /dev/null -s http://example.com What it does:\nMeasures the total time taken to get a response from the server without saving the content.\nDownload a File with Authentication Command:\n1 curl -u username:password -O http://example.com/protected/file.zip What it does:\nDownloads a file from a password-protected area by providing login credentials.\nUpload a File Command:\n1 curl -X POST -F \u0026#34;file=@/path/to/file.txt\u0026#34; http://example.com/upload What it does:\nUploads a file to a server via an HTTP POST request.\nUse Proxy Command:\n1 curl -x http://proxyserver:port http://example.com What it does:\nRoutes the request through a proxy server.\nLimit Download Speed Command:\n1 curl --limit-rate 100k http://example.com/file.zip What it does:\nLimits the download speed to 100 KB/s.\nResume a Download Command:\n1 curl -C - -O http://example.com/largefile.zip What it does:\nResumes an interrupted download of a file.\nPerform FTP Operations Command:\n1 curl ftp://example.com/file.txt --user username:password What it does:\nDownloads a file from an FTP server using credentials.\nDebug Requests Command:\n1 curl -v http://example.com What it does:\nShows detailed information about the request and response, useful for debugging.\nUse a Specific Protocol Command:\n1 curl --http2 http://example.com What it does:\nForces the request to use HTTP/2 protocol.\nSuppress Output Command:\n1 curl -s http://example.com What it does:\nRuns curl silently, suppressing progress and error messages.\nTest Authentication Command:\n1 curl -u user:pass http://example.com What it does:\nTests HTTP Basic Authentication by providing a username and password.\nSend a DELETE Request Command:\n1 curl -X DELETE http://example.com/api/resource/123 What it does:\nSends a DELETE request to remove a resource on the server.\nSave Cookies Command:\n1 curl -c cookies.txt http://example.com What it does:\nSaves server-set cookies to a file.\nUse Saved Cookies Command:\n1 curl -b cookies.txt http://example.com What it does:\nUses the previously saved cookies for the request.\nUse Multiple URLs Command:\n1 curl -O http://example.com/file1.txt -O http://example.com/file2.txt What it does:\nDownloads multiple files in a single command.\n","permalink":"//localhost:1313/posts/curl/","summary":"This is sparta","title":"What is SSO"},{"content":"Understanding DNS : How the Internet Knows Where to Go The Domain Name System (DNS) is like the internet\u0026rsquo;s phonebook. It helps translate human-friendly domain names (e.g., samirdeshar.com.np) into machine-friendly IP addresses (e.g., 172.66.44.181) so computers can find and connect to websites or services.\nWhat Is DNS? Imagine if you had to memorize IP addresses like 172.66.44.181 every time you wanted to visit a website. That would be difficult! DNS solves this by associating domain names with their respective IP addresses. It works in the background whenever you access a website, send an email, or use an online service.\nKey Terms for Beginners:\nDomain Name: The human-readable name (e.g., example.com). IP Address: The numerical address of a server (e.g., 192.168.1.1). DNS Resolver: A server that helps your device find the IP address for a domain name. How DNS Works: Step-by-Step Here’s a beginner-friendly breakdown of how DNS translates a domain name to an IP:\nYou Type a Domain Name:\nFor example, you type samirdeshar.com.np in your browser. Your computer needs to find the IP address for this domain to connect. Query Sent to DNS Resolver:\nYour device asks a DNS resolver (provided by your ISP or a public DNS like Google DNS) to resolve the domain name into an IP address. Resolver Queries Root Servers:\nIf the resolver doesn’t already know the answer, it asks a root server. Root servers guide the resolver to the next step by pointing it to the appropriate Top-Level Domain (TLD) server. Querying TLD Servers:\nThe resolver contacts a TLD server (e.g., .np for Nepal). TLD servers store information about domains within their extension. Finding Authoritative Nameservers:\nThe TLD server responds with the authoritative nameserver for the domain (e.g., Cloudflare for samirdeshar.com.np). Getting the IP Address:\nThe resolver queries the authoritative nameserver, which provides the IP address of the domain. Returning the IP to Your Browser:\nThe resolver sends the IP address back to your browser, which uses it to connect to the server and load the website. A Practical Example Let’s apply this to samirdeshar.com.np:\nYou visit samirdeshar.com.np. Your browser sends a request to a DNS resolver (e.g., Google DNS at 8.8.8.8). The resolver contacts a root server for .np. The root server directs the resolver to the .np TLD servers. The .np TLD server directs the resolver to Cloudflare’s DNS servers, which manage samirdeshar.com.np. Cloudflare’s server provides the IP address (e.g., 172.66.44.181). The browser connects to 172.66.44.181 to load the website. The Basics of DNS Records DNS uses different types of records to manage domains. Here are the most common:\nA Record: Maps a domain to an IPv4 address. AAAA Record: Maps a domain to an IPv6 address. CNAME Record: Creates an alias for another domain. MX Record: Directs email to a mail server. NS Record: Points to the nameservers for a domain. What Happens Behind the Scenes? DNS uses tags and zones to organize and manage data:\nZones define administrative boundaries, such as the .np zone for Nepal. Tags (like VLAN tagging in networks) help identify traffic and maintain separation, especially in complex environments like hosting multiple subdomains. Real-Life Applications of DNS Browsing Websites: DNS makes accessing example.com possible without memorizing IP addresses. Email Delivery: MX records ensure emails reach the correct servers. Load Balancing: DNS directs users to the nearest server for faster responses. Content Delivery Networks (CDNs): DNS routes requests to distributed servers based on geography. DNS Security Concerns DNS Spoofing: Hackers can redirect users to malicious websites. DNSSEC (DNS Security Extensions) helps by validating responses. Cache Poisoning: Attackers inject false data into DNS caches. Using trusted resolvers mitigates this. DDoS Attacks: Public DNS servers can be overloaded. Rate limiting and filtering help protect them. How to Check DNS Resolution Here are some commands to explore DNS on your system:\nTrace DNS Resolution/(trace the path):\n1 dig +trace samirdeshar.com.np Query Root Servers:\n1 dig @a.root-servers.net samirdeshar.com.np Querying the Authoritative Servers directly:\n1 dig @jobs.ns.cloudflare.com samirdeshar.com.np Get IP Address:\n1 dig samirdeshar.com.np +short Clean output (just the IP):\n1 dig @jobs.ns.cloudflare.com samirdeshar.com.np +short What dig +trace Shows The dig +trace command shows each step in the DNS resolution path, from root servers to the authoritative server:\nRoot Servers: The first part of the output shows which root server was queried and which .np TLD servers it provided in response. .np TLD Servers: The next section shows the .np servers directing the resolver to the authoritative Cloudflare DNS servers. Authoritative Server: Finally, the output shows Cloudflare’s authoritative server providing the IP addresses of samirdeshar.com.np. In summary, DNS resolution goes through these steps: Root Servers → .np TLD Servers → Authoritative Cloudflare Servers → IP Address for the website.\nConclusion DNS is the silent engine behind the internet. Without it, we\u0026rsquo;d be stuck memorizing IP addresses. Whether you’re a beginner or a seasoned techie, understanding DNS is crucial for navigating and managing networks. From resolving your favorite websites to enabling secure communication, DNS underpins how we interact with the web today.\n","permalink":"//localhost:1313/posts/dns/","summary":"This is sparta","title":"What is SSO"},{"content":"So basically the half proxies are those that initiate connection to the proxy and forward the connection to the server. While the server repose directly back to the client. This is also known as DSR(Direct Server Response).\nStep on how this works and why would client accept the response from a completely new ip than the proxy VS which we had requested for? Let\u0026rsquo;s assume following. CLIENT -\u0026gt; 192.168.1.1 VS/PROXY -\u0026gt; 10.2.0.1 SERVER -\u0026gt; 10.3.0.1\nSTEPS:\nClient Initiates a Request:\nClient IP: 192.168.1.1 Virtual Server (VS)/Proxy IP: 10.2.0.1 Server IP: 10.3.0.1 The client sends a request to the Virtual Server (VS) or proxy IP (10.2.0.1). This VS IP is usually configured on the proxy or load balancer.\nSource IP: 192.168.1.1 Destination IP: 10.2.0.1 (VS/Proxy) Proxy Receives and Forwards the Request:\nThe request reaches the VS (10.2.0.1). In a half proxy/DSR setup, the proxy does not modify the source or destination IP addresses when forwarding the request to the backend server (10.3.0.1). The proxy simply forwards the packet to the backend server with the following headers: Source IP: 192.168.1.1 Destination IP: 10.2.0.1 (VS/Proxy IP)\nServer Accepts the Packet with VS IP:\nHere’s where DSR comes into play. The backend server (10.3.0.1) is configured with a secondary IP address (also known as a loopback or alias IP) that matches the VS IP (10.2.0.1). Because the server sees the destination IP as 10.2.0.1, and it has this IP configured as a secondary IP, it accepts the packet as if it was meant for itself. Server Sends the Response:\nWhen the server responds, the source IP of the response is set to the destination IP of the incoming packet, which is the VS IP (10.2.0.1).\nThe response packet has the following headers\nSource IP: 10.2.0.1 (VS IP, configured as server loopback) Destination IP: 192.168.1.1 (Client IP) Response Goes Directly to the Client:\nThe server sends the response directly to the client (192.168.1.1), bypassing the proxy or VS. This is why it’s called Direct Server Return (DSR). The client receives the response directly from the server (10.3.0.1), but it appears to be from the VS IP (10.2.0.1), which the client originally requested. Why Does the Client Accept the Response from a Different IP? The key is that the client sees the same IP address it initially requested (i.e., 10.2.0.1). Even though the response is coming directly from the backend server, the source IP in the response is still set to the VS IP (10.2.0.1), making it look like it’s coming from the proxy or load balancer that the client originally contacted. Important Points in DSR/Half Proxy: Server Configuration: The backend server must have the VS IP configured as a loopback or secondary IP to accept traffic destined for it. IP Address Handling: The VS IP is used for both forwarding the request and as the source of the server’s response, even though the response is sent directly from the server to the client. Direct Server Response: The server bypasses the proxy for responses, reducing the proxy’s load and improving response times. ","permalink":"//localhost:1313/posts/halfproxy/","summary":"This is sparta","title":"What is SSO"},{"content":"What is Kerberos? Kerberos is a secure network authentication protocol, widely used as the default authentication mechanism for Microsoft Windows domains. It uses a ticket-based system and strong encryption to authenticate users and services securely. Kerberos improves on older protocols like NTLM by employing third-party ticket authorization and enhanced security measures. However, it still has exploitable vulnerabilities that attackers can leverage.\nHow Does Kerberos Work? Kerberos operates as a Single Sign-On (SSO) protocol using a ticket-based authentication scheme. The user’s password is stored as a hashed value in the Security Account Manager (SAM) database on Windows systems:\n1 C:\\Windows\\System32\\config\\SAM Key steps in Kerberos authentication:\nPassword Hash Encryption: The user’s password hash is used to encrypt authentication messages. Server Decryption: The server validates the user by decrypting the messages with the stored password hash. Common Terminology in Kerberos Ticket Granting Ticket (TGT): An authentication ticket used to request service tickets for accessing domain resources. Key Distribution Center (KDC): A central service that issues TGTs and service tickets. It includes: Authentication Service (AS): Issues TGTs to users. Ticket Granting Service (TGS): Issues service tickets based on valid TGTs. Service Principal Name (SPN): An identifier for a specific service instance linked to a domain service account. Long Term Secret Keys: KDC LT Key: Encrypts TGTs and signs the Privilege Attribute Certificate (PAC). Client LT Key: Encrypts timestamps and session keys during authentication. Service LT Key: Encrypts service tickets and signs the PAC. Session Key: A temporary key issued for communication between the client and services. Privilege Attribute Certificate (PAC): Contains user information, including privileges, signed to validate authenticity. How Kerberos Works: Step-by-Step 1. Authentication Phase (Getting a TGT) User Login: The user enters their password, which is hashed (e.g., SHA-256). Request to AS: The client sends the username to the Authentication Service (AS). TGT Creation: The AS verifies the user, generates a TGT, and encrypts it using the user’s password hash. Receive TGT: The client decrypts the TGT to authenticate and holds the TGT for future service requests. 2. Ticket Granting Phase (Getting a Service Ticket) Request to TGS: The client sends the TGT and an Authenticator (timestamp encrypted with the session key) to the TGS. Service Ticket Creation: The TGS verifies the TGT and Authenticator, then issues a Service Ticket encrypted with the target service\u0026rsquo;s key. Receive Service Ticket: The client uses this ticket to access the requested service. 3. Service Access Phase (Using the Service Ticket) Service Request: The client sends the Service Ticket and a new Authenticator to the target service. Access Validation: The service validates the ticket and Authenticator, granting access if they are valid. Kerberos Tickets Overview TGT (Ticket Granting Ticket): Used to request service tickets from the KDC. Service Tickets: Specific to services, allowing users to authenticate and access resources. Tickets can be represented in different formats (e.g., .kirbi for Rubeus or .ccache for Impacket) and may be base64-encoded for certain attacks.\nSteps in Kerberos Authentication AS-REQ: The client requests a TGT from the AS. AS-REP: The AS sends back an encrypted TGT. TGS-REQ: The client sends the TGT to the TGS with the SPN of the service. TGS-REP: The TGS validates the TGT and sends a Service Ticket. AP-REQ: The client requests the service with the Service Ticket. AP-REP: The service validates the ticket and grants access. Attacking the Kerberos Protocol Kerbrute A powerful tool for enumerating Active Directory users by exploiting Kerberos pre-authentication vulnerabilities.\nExamples:\n1 2 kerbrute userenum --dc CONTROLLER.local -d CONTROLLER.local User.txt kerbrute userenum users.txt -d spookysec.local --dc 10.10.74.37 These commands attempt to brute-force and enumerate valid usernames by sending requests to the KDC.\nKerberos remains a critical authentication protocol in modern networks. While it enhances security, understanding its mechanics and vulnerabilities is essential for both defensive and offensive cybersecurity operations.\n","permalink":"//localhost:1313/posts/learningkerberos/","summary":"This is sparta","title":"What is SSO"},{"content":"OAuth is a method for authorization that allows access to third-party applications or services without requiring the sharing of usernames and passwords.\nHow OAuth 2.0 Works? OAuth 2.0 is an authorization protocol designed to provide secure delegated access to resources without exposing user credentials to third-party applications.\nKey Components: Resource Owner: The user who owns the data or resource. Client: The application requesting access to the user’s resource on behalf of the user (e.g., a web or mobile app). Resource Server: The server hosting the protected resources (e.g., an API). Authorization Server: The server that authenticates the user and issues access tokens. This may be the same as the Resource Server. OAuth Flows (Grant Types): OAuth 2.0 offers different authorization flows based on the type of application and security requirements.\n1. Authorization Code Grant (Most Secure) This is the most commonly used flow for server-side web applications.\nSteps:\nClient Requests Authorization: The client redirects the user to the authorization server with a request for permission to access the resource. User Authorizes the Client: The user logs into the authorization server and consents to the requested access. Authorization Code Issued: Upon approval, the authorization server redirects the user back to the client with an authorization code. Client Exchanges Code for Access Token: The client securely exchanges the authorization code for an access token by sending a request to the authorization server. Client Accesses Resource: The client uses the access token to request the resource from the Resource Server. ![[Pasted image 20241017145740.png]] 2. Implicit Grant (Less Secure) Primarily used by single-page apps (SPAs) or public clients where keeping credentials secret is difficult.\nSteps:\nClient Requests Authorization: The client redirects the user to the authorization server. User Authorizes: The user approves the request, and the authorization server redirects the user back with an access token. Client Accesses Resource: The client immediately uses the access token to request resources. This flow is considered less secure because the access token is exposed in the URL.\n3. Client Credentials Grant Used for machine-to-machine communication without user interaction.\nSteps:\nClient Requests Access Token: The client directly requests an access token by presenting its client ID and client secret to the authorization server. Access Token Issued: If the credentials are valid, the authorization server issues an access token. Client Accesses Resource: The client uses the access token to access the protected resource. ![[Pasted image 20241017150006.png]]\n4. Password Grant (Deprecated) Allows the client to use the user’s credentials (username and password) to directly request an access token.\nSteps:\nClient Sends Credentials: The client sends the user’s username and password to the authorization server. Access Token Issued: The server validates the credentials and issues an access token. Client Accesses Resource: The client uses the access token to request resources. This method is not recommended due to security concerns, as it requires the user to share their credentials with the client.\n5. Refresh Token Allows the client to obtain a new access token without involving the user when the original token expires.\nSteps:\nClient Sends Refresh Token: The client sends a valid refresh token to the authorization server. Access Token Issued: The server responds with a new access token. Security Mechanisms in OAuth 2.0 OAuth 2.0 includes several security measures to protect data and prevent unauthorized access:\nAccess Token Expiration: Tokens have a limited lifespan to minimize the risk of misuse. Scopes: Tokens include scopes that define the level of access to resources. This ensures the client only accesses what’s necessary. Token Encryption: In some cases, access tokens are encrypted to prevent unauthorized inspection. Authorization Code Exchange: In the authorization code flow, the token is not returned directly to the client. Instead, it’s exchanged securely using client credentials, reducing exposure. PKCE (Proof Key for Code Exchange): An extension to OAuth 2.0 that adds an extra layer of security to public clients (like mobile apps) by mitigating the risk of code interception. JWT (JSON Web Token) is a compact, URL-safe token used to represent claims between two parties. It allows for secure transmission of information, often used for authorization without sharing credentials like usernames or passwords.\nJWT consists of three parts: Header: This contains metadata about the token, including the type (typically \u0026ldquo;JWT\u0026rdquo;) and the algorithm used for signing (e.g., HS256, RS256). Payload: The payload carries claims, which are pieces of data about the user or session, such as the user identity, roles, or expiration time (exp). This is the part where the user information is stored. Signature: The signature ensures the integrity of the token. It is created by combining the header and payload, hashing them, and then signing with a secret or private key. The signature is what protects the token from being tampered with. How Verification Works: The signature is verified by the recipient (often the resource server) to ensure the JWT hasn’t been altered. If asymmetric algorithms (like RSA) are used: The server signs the token with a private key. The recipient (resource server) uses the public key to decode the signature and validate that the content (header and payload) has not been modified. The hash from the header and payload is recalculated by the resource server, and if it matches the signature, the token is verified as valid. Access Granting: Once the JWT is validated and confirmed to be untampered, the resource server (the application the user is trying to access) grants access based on the claims (e.g., user identity, permissions) in the payload. ","permalink":"//localhost:1313/posts/apm/oauth/","summary":"This is sparta","title":"What is OAuth"}]